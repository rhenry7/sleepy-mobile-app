{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _react = require(\"react\");\n\nvar TrackPlayer = _interopRequireWildcard(require(\"./index\"));\n\nvar _eventTypes = _interopRequireDefault(require(\"./eventTypes\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar usePlaybackState = function usePlaybackState() {\n  var _useState = (0, _react.useState)(TrackPlayer.STATE_NONE),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  (0, _react.useEffect)(function () {\n    function setPlayerState() {\n      var playerState;\n      return _regenerator.default.async(function setPlayerState$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regenerator.default.awrap(TrackPlayer.getState());\n\n            case 2:\n              playerState = _context.sent;\n              setState(playerState);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n\n    setPlayerState();\n    var sub = TrackPlayer.addEventListener(TrackPlayer.TrackPlayerEvents.PLAYBACK_STATE, function (data) {\n      setState(data.state);\n    });\n    return function () {\n      sub.remove();\n    };\n  }, []);\n  return state;\n};\n\nvar useTrackPlayerEvents = function useTrackPlayerEvents(events, handler) {\n  var savedHandler = (0, _react.useRef)();\n  (0, _react.useEffect)(function () {\n    savedHandler.current = handler;\n  }, [handler]);\n  (0, _react.useEffect)(function () {\n    if (__DEV__) {\n      var allowedTypes = Object.values(_eventTypes.default);\n      var invalidTypes = events.filter(function (type) {\n        return !allowedTypes.includes(type);\n      });\n\n      if (invalidTypes.length) {\n        console.warn('One or more of the events provided to useTrackPlayerEvents is ' + (\"not a valid TrackPlayer event: \" + invalidTypes.join('\\', \\'') + \". \") + 'A list of available events can be found at ' + 'https://react-native-kit.github.io/react-native-track-player/documentation/#events');\n      }\n    }\n\n    var subs = events.map(function (event) {\n      return TrackPlayer.addEventListener(event, function (payload) {\n        return savedHandler.current(_objectSpread(_objectSpread({}, payload), {}, {\n          type: event\n        }));\n      });\n    });\n    return function () {\n      subs.forEach(function (sub) {\n        return sub.remove();\n      });\n    };\n  }, events);\n};\n\nvar useInterval = function useInterval(callback, delay) {\n  var savedCallback = (0, _react.useRef)();\n  (0, _react.useEffect)(function () {\n    savedCallback.current = callback;\n  });\n  (0, _react.useEffect)(function () {\n    if (!delay) return;\n    var id = setInterval(savedCallback.current, delay);\n    return function () {\n      return clearInterval(id);\n    };\n  }, [delay]);\n};\n\nvar useWhenPlaybackStateChanges = function useWhenPlaybackStateChanges(callback) {\n  useTrackPlayerEvents([_eventTypes.default.PLAYBACK_STATE], function (_ref) {\n    var state = _ref.state;\n    callback(state);\n  });\n  (0, _react.useEffect)(function () {\n    var didCancel = false;\n\n    var fetchPlaybackState = function fetchPlaybackState() {\n      var playbackState;\n      return _regenerator.default.async(function fetchPlaybackState$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _regenerator.default.awrap(TrackPlayer.getState());\n\n            case 2:\n              playbackState = _context2.sent;\n\n              if (!didCancel) {\n                callback(playbackState);\n              }\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    fetchPlaybackState();\n    return function () {\n      didCancel = true;\n    };\n  }, []);\n};\n\nvar usePlaybackStateIs = function usePlaybackStateIs() {\n  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n    states[_key] = arguments[_key];\n  }\n\n  var _useState3 = (0, _react.useState)(),\n      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n      is = _useState4[0],\n      setIs = _useState4[1];\n\n  useWhenPlaybackStateChanges(function (state) {\n    setIs(states.includes(state));\n  });\n  return is;\n};\n\nvar useTrackPlayerProgress = function useTrackPlayerProgress() {\n  var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n  var initialState = {\n    position: 0,\n    bufferedPosition: 0,\n    duration: 0\n  };\n\n  var _useState5 = (0, _react.useState)(initialState),\n      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),\n      state = _useState6[0],\n      setState = _useState6[1];\n\n  var getProgress = function getProgress() {\n    var _await$Promise$all, _await$Promise$all2, position, bufferedPosition, duration;\n\n    return _regenerator.default.async(function getProgress$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return _regenerator.default.awrap(Promise.all([TrackPlayer.getPosition(), TrackPlayer.getBufferedPosition(), TrackPlayer.getDuration()]));\n\n          case 2:\n            _await$Promise$all = _context3.sent;\n            _await$Promise$all2 = (0, _slicedToArray2.default)(_await$Promise$all, 3);\n            position = _await$Promise$all2[0];\n            bufferedPosition = _await$Promise$all2[1];\n            duration = _await$Promise$all2[2];\n            setState({\n              position: position,\n              bufferedPosition: bufferedPosition,\n              duration: duration\n            });\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var needsPoll = usePlaybackStateIs(TrackPlayer.STATE_PLAYING, TrackPlayer.STATE_BUFFERING);\n  useInterval(getProgress, needsPoll ? interval : null);\n  return state;\n};\n\nmodule.exports.usePlaybackState = usePlaybackState;\nmodule.exports.useTrackPlayerEvents = useTrackPlayerEvents;\nmodule.exports.useTrackPlayerProgress = useTrackPlayerProgress;","map":{"version":3,"sources":["/Users/ramonehenry/Documents/code/codeprojects/AwesomeProject/node_modules/react-native-track-player/lib/hooks.js"],"names":["usePlaybackState","TrackPlayer","STATE_NONE","state","setState","setPlayerState","getState","playerState","sub","addEventListener","TrackPlayerEvents","PLAYBACK_STATE","data","remove","useTrackPlayerEvents","events","handler","savedHandler","current","__DEV__","allowedTypes","Object","values","invalidTypes","filter","type","includes","length","console","warn","join","subs","map","event","payload","forEach","useInterval","callback","delay","savedCallback","id","setInterval","clearInterval","useWhenPlaybackStateChanges","didCancel","fetchPlaybackState","playbackState","usePlaybackStateIs","states","is","setIs","useTrackPlayerProgress","interval","initialState","position","bufferedPosition","duration","getProgress","Promise","all","getPosition","getBufferedPosition","getDuration","needsPoll","STATE_PLAYING","STATE_BUFFERING","module","exports"],"mappings":"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","sourcesContent":["import { useEffect, useState, useDebugValue, useRef } from 'react';\r\nimport * as TrackPlayer from './index';\r\nimport TrackPlayerEvents from './eventTypes';\r\n\r\n/**\r\n * @description\r\n *   Get current playback state and subsequent updatates\r\n */\r\nconst usePlaybackState = () => {\r\n    const [state, setState] = useState(TrackPlayer.STATE_NONE)\r\n\r\n    useEffect(() => {\r\n        async function setPlayerState() {\r\n            const playerState = await TrackPlayer.getState()\r\n            setState(playerState)\r\n        }\r\n\r\n        setPlayerState()\r\n        \r\n        const sub = TrackPlayer.addEventListener(TrackPlayer.TrackPlayerEvents.PLAYBACK_STATE, data => {\r\n            setState(data.state)\r\n        })\r\n\r\n        return () => {\r\n            sub.remove()\r\n        }\r\n    }, [])\r\n\r\n    return state\r\n}\r\n\r\n/**\r\n * @description\r\n *   Attaches a handler to the given TrackPlayer events and performs cleanup on unmount\r\n * @param {Array<string>} events - TrackPlayer events to subscribe to\r\n * @param {(payload: any) => void} handler - callback invoked when the event fires\r\n */\r\nconst useTrackPlayerEvents = (events, handler) => {\r\n    const savedHandler = useRef();\r\n\r\n    useEffect(() => {\r\n        savedHandler.current = handler;\r\n    }, [handler]);\r\n\r\n    useEffect(\r\n        () => {\r\n            if (__DEV__) {\r\n                const allowedTypes = Object.values(TrackPlayerEvents);\r\n                const invalidTypes = events.filter(type => !allowedTypes.includes(type));\r\n                if (invalidTypes.length) {\r\n                    console.warn(\r\n                        'One or more of the events provided to useTrackPlayerEvents is ' +\r\n                        `not a valid TrackPlayer event: ${invalidTypes.join('\\', \\'')}. ` +\r\n                        'A list of available events can be found at ' +\r\n                        'https://react-native-kit.github.io/react-native-track-player/documentation/#events'\r\n                    )\r\n                }\r\n            }\r\n\r\n            const subs = events.map(event =>\r\n                TrackPlayer.addEventListener(event,\r\n                    (payload) => savedHandler.current({ ...payload, type: event })\r\n                )\r\n            );\r\n\r\n            return () => {\r\n                subs.forEach(sub => sub.remove());\r\n            }\r\n        },\r\n        events\r\n    );\r\n}\r\n\r\nconst useInterval = (callback, delay) => {\r\n    const savedCallback = useRef();\r\n\r\n    useEffect(() => {\r\n        savedCallback.current = callback;\r\n    })\r\n\r\n    useEffect(() => {\r\n        if (!delay) return;\r\n        const id = setInterval(savedCallback.current, delay);\r\n        return () => clearInterval(id);\r\n    }, [delay]);\r\n}\r\n\r\nconst useWhenPlaybackStateChanges = callback => {\r\n    useTrackPlayerEvents(\r\n        [TrackPlayerEvents.PLAYBACK_STATE],\r\n        ({ state }) => {\r\n            callback(state);\r\n        }\r\n    );\r\n    useEffect(() => {\r\n        let didCancel = false;\r\n        const fetchPlaybackState = async () => {\r\n            const playbackState = await TrackPlayer.getState();\r\n            if (!didCancel) {\r\n                callback(playbackState);\r\n            }\r\n        }\r\n        fetchPlaybackState();\r\n        return () => { didCancel = true };\r\n    }, []);\r\n}\r\n\r\nconst usePlaybackStateIs = (...states) => {\r\n    const [is, setIs] = useState();\r\n    useWhenPlaybackStateChanges(state => {\r\n        setIs(states.includes(state));\r\n    });\r\n\r\n    return is;\r\n}\r\n\r\n/**\r\n * @description\r\n *   Poll for track progress for the given interval (in miliseconds)\r\n * @param {number} interval - ms interval\r\n * @returns {[\r\n *   {\r\n *      progress: number,\r\n *      bufferedPosition: number,\r\n *      duration: number\r\n *   },\r\n *   (interval: number) => void\r\n * ]}\r\n */\r\nconst useTrackPlayerProgress = (interval = 1000) => {\r\n    const initialState = {\r\n        position: 0,\r\n        bufferedPosition: 0,\r\n        duration: 0\r\n    };\r\n\r\n    const [state, setState] = useState(initialState);\r\n\r\n    const getProgress = async () => {\r\n        const [position, bufferedPosition, duration] = await Promise.all([\r\n            TrackPlayer.getPosition(),\r\n            TrackPlayer.getBufferedPosition(),\r\n            TrackPlayer.getDuration()\r\n        ])\r\n        setState({ position, bufferedPosition, duration });\r\n    }\r\n\r\n    const needsPoll = usePlaybackStateIs(\r\n        TrackPlayer.STATE_PLAYING,\r\n        TrackPlayer.STATE_BUFFERING\r\n    );\r\n    useInterval(getProgress, needsPoll ? interval : null);\r\n    return state;\r\n}\r\n\r\n\r\n// Exports\r\nmodule.exports.usePlaybackState = usePlaybackState\r\nmodule.exports.useTrackPlayerEvents = useTrackPlayerEvents\r\nmodule.exports.useTrackPlayerProgress = useTrackPlayerProgress\r\n"]},"metadata":{},"sourceType":"script"}